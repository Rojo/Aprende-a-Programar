Escribiendo tus propios métodos

Como hemos visto, los ciclos e iteradores nos permiten hacer lo mismo (ejecutar el mismo código) una y otra vez. Sin embargo, puede pasar que deseemos hacer algo cierto número de veces desde diferentes partes del programa.

Por ejemplo, digamos que escribíamos un programa de cuestionarios para un estudiante de psicología. De los estudiantes de psicología que he conocido y los cuestionarios que me han dado, seguramente sería algo como esto:

puts 'Hola y gracias por tomar un tipo de tiempo para ayudarme con éste'
puts 'experimento. Mi experimento trata de como se sienten las personas en'
puts 'relación con la comida mexicana. Sólo ten presente en tu mente la comida'
puts 'mexicana e intenta responder cada pregunta honestamente con un «sí» o un'
puts '«no». El experimento no tiene nada que ver con mojar la cama.'

# Hacemos éstas preguntas, pero ignoramos las respuestas.

buenaRespuesta = false
while (not buenaRespuesta)
  puts '¿Te gusta comer tacos?'
  respuesta = gets.chomp.downcase

  if (respuesta == 'sí' or respuesta == 'no')
    buenaRespuesta = true
  else
    puts 'Por favor, responde «sí» o «no».'
  end 
end

buenaRespuesta = false
while (not buenaRespuesta)
  puts '¿Te gusta comer burritos?'
  respuesta = gets.chomp.downcase

  if (respuesta == 'sí' or respuesta == 'no')
    buenaRespuesta = true
  else
    puts 'Por favor, responde «sí» o «no».'
  end 
end

# Pero sí ponemos atención a *ésta* respuesta.

buenaRespuesta = false
while (not buenaRespuesta)
  puts '¿Aún mojas la cama?'
  respuesta = gets.chomp.downcase

  if (respuesta == 'sí' or respuesta == 'no')
    buenaRespuesta = true
    
    if respuesta == 'sí'
      mojaLaCama = true
    else
      mojaLaCama = false
    end
  else
    puts 'Por favor, responde «sí» o «no».'
  end 
end

buenaRespuesta = false
while (not buenaRespuesta)
  puts '¿Te gusta comer chimichangas?'
  respuesta = gets.chomp.downcase

  if (respuesta == 'sí' or respuesta == 'no')
    buenaRespuesta = true
  else
    puts 'Por favor, responde «sí» o «no».'
  end 
end

puts 'Sólo unas cuantas preguntas más...'

buenaRespuesta = false
while (not buenaRespuesta)
  puts '¿Te gusta comer sopapillas?'
  respuesta = gets.chomp.downcase

  if (respuesta == 'sí' or respuesta == 'no')
    buenaRespuesta = true
  else
    puts 'Por favor, responde «sí» o «no».'
  end 
end

# Hace un montón de otras preguntas sobre comida mexicana.

puts
puts 'EXPLICACIÓN:'
puts 'Gracias por tomar tiempo para ayudarme con éste experimento. En realidad,'
puts 'el experimento no tiene nada que ver con comida mexicana. Es un'
puts 'experimento acerca de las personas que aún mojan la cama. La comida'
puts 'mexicana sólo estaba ahí como distracción, con la esperanza de que'
puts 'responderías con más honestidad. Gracias de nuevo.'
puts
puts mojaLaCama

Hola y gracias por tomar un tipo de tiempo para ayudarme con éste experimento. Mi experimento trata de como se sienten las personas en relación con la comida mexicana. Sólo ten presente en tu mente la comida mexicana e intenta responder cada pregunta honestamente con un «sí» o un «no». El experimento no tiene nada que ver con mojar la cama.

¿Te gusta comer tacos?
sí
¿Te gusta comer burritos?
sí
¿Aún mojas la cama?
¡claro qué no!
Por favor, responde «sí» o «no».
¿Aún mojas la cama?
NO
Sólo unas cuantas preguntas más...
¿Te gusta comer chimichangas?
sí
¿Te gusta comer sopapillas?
sí

EXPLICACIÓN:
Gracias por tomar tiempo para ayudarme con éste experimento. En realidad, el experimento no tiene nada que ver con comida mexicana. Es un experimento acerca de las personas que aún mojan la cama. La comida mexicana sólo estaba ahí como distracción, con la esperanza de que responderías con más honestidad. Gracias de nuevo.

false

Ese fue un programa bastante largo, con muchas repeticiones. (Todas las secciones de código alrededor de preguntas sobre comida mexicana eran idénticas, y la pregunta sobre «mojar la cama» fue sólo ligeramente diferente. La repetición es mala. Aun así, no podemos usar un gran ciclo o un iterador, debido a que algunas veces tenemos cosas que queremos hacer entre preguntas. En situaciones como ésta, es mejor escribir un método.

Se hace así:

def muge
  puts 'muuuuuu...'
end

Uh... Nuestro programa no mugió. ¿Por qué no? Porque no le indicamos que lo hiciera. Le indicamos como mugir, pero nunca le dijimos que lo hiciera. Intentemos de nuevo:

def muge
  puts 'muuuuuu...'
end

muge
muge
puts 'coin-coin'
muge
muge

muuuuuu...
muuuuuu...
coin-coin
muuuuuu...
muuuuuu...

¡Ahhh, mucho mejor! (Sólo en caso de que no hables francés, ese fue un pato francés a mitad del programa. En Francia, los patos dicen «coin-coin».)

Definimos el método muge. (Se usa que los nombres de métodos, como los nombres de variables, comiencen con una letra minúscula. Aunque, hay algunas excepciones como + o ==.) Pero, ¿no tienen los métodos que estar siempre asociados con objetos? Bueno, sí, lo están, y en éste caso (al igual que puts y gets), el método está asociado con el objeto que representa el programa completo. En el siguiente capítulo veremos como agregar métodos a otros objetos. Pero primero...

Parámetros en los métodos
Tal vez hayas notado que algunos métodos (como gets, to_s, reverse...) pueden ser simplemente llamados sobre un objeto. Sin embargo, otros métodos (cómo +, -, puts...) toman parámetros para indicarle al objeto cómo realizar el método. Por ejemplo, no dirías simplemente 5+, ¿verdad? Porque le estarías diciendo a 5 que sume, pero no le estarías diciendo qué sumar.

Para añadir un parámetro a muge (digamos, el número de veces que debe mugir), hacemos esto:

def muge numeroDeVeces
  puts 'muuuuuuu...' * numeroDeVeces
end

muge 3
puts 'oinc, oinc'
muge # Provocará un error porque falta un parámetro

muuuuuuu...muuuuuuu...muuuuuuu...
oinc, oinc
#<ArgumentError: wrong number of arguments (0 for 1)>

numeroDeVeces es una variable que apunta al parámetro pasado al método. Lo diré de nuevo ya que es un poco confuso: numeroDeVeces es una variable que apunta al parámetro pasado al método. Así que, si escribo muge 3, el parámetro es 3 y la variable numeroDeVeces apunta a 3.

Como puedes ver, el parámetro es ahora requerido. Después de todo, ¿cómo puede muge multiplicar 'muuuuuuu...' si no le das ningún parámetro? Tu pobre computadora no tiene idea.

Si los objetos en Ruby son como los sustantivos en español, y los métodos son como los verbos, entonces puedes pensar en los parámetros como adverbios (como en muge, donde el parámetro le dice como debe mugir) u otras veces como objetos directos (como con puts, donde el parámetro es lo que se imprime).

Variables locales
En el siguiente programa hay dos variables:

def duplicaEsto numero
  numeroPor2 = numero * 2
  puts numero.to_s + ' al doble es ' + numeroPor2.to_s
end

duplicaEsto 44

44 al doble es 88

Las variables son numero y numeroPor2. Ambas se encuentran dentro del método duplicaEsto. Estás (y todas las variables que has visto hasta ahora) son variables locales. Esto significa que viven dentro del método y no pueden salir. Si intentas llamarlas afuera, obtendrás un error:

def duplicaEsto numero
  numeroPor2 = numero * 2
  puts numero.to_s + ' al doble es ' + numeroPor2.to_s
end

duplicaEsto 44
puts numeroPor2.to_s

44 al doble es 88
#<NameError: undefined local variable or method `numTimes2' for #<StringIO:0x82ba21c>>

Variable local indefinida... De hecho, sí definimos esa variable local, pero no es local desde donde intentamos usarla; es local al método.

Esto podría parecer un inconveniente, pero en realidad es bastante bueno. Mientras que eso significa que no puedes acceder a variables dentro de los métodos, también significa que ellos no tienen acceso a tus variables, y por lo tanto, no las pueden afectar.

def pestecilla var
  var = nil
  puts 'Pestecilla: ¡Ja, ja! ¡He arruinado tu variable!'
end

var = 'Programa: ¡No puedes ni tocar mi variable!'
pestecilla var
puts var

Pestecilla: ¡Ja, ja! ¡He arruinado tu variable!
Programa: ¡No puedes ni tocar mi variable!

En realidad hay dos variables llamadas var en ese pequeño programa: una dentro de la pequeñaPeste, y la otra fuera de ella. Cuando llamamos a pequeñaPeste var, en realidad sólo hicimos que ambas variables apuntaran a la misma cadena. Después, la pequeñaPeste apunto su propia var local hacia nil, pero no hizo nada a la var fuera del método.

Retorno de valores
Probablemente te has dado cuenta que algunos métodos regresan algo cuando los llamas. Por ejemplo, gets retorna una cadena de caracteres (la cadena que escribiste con el teclado), y el método + en 5 + 3 (que es en realidad 5.+(3)), retorna 8. Los métodos aritméticos para números retornan números, y los métodos aritméticos para cadenas retornan cadenas.

Es importante entender la diferencia entre métodos retornando un valor a la parte del programa donde fueron llamados y la presentación de información en pantalla, como lo hace puts. Así, 5 + 3 retorna 8, no imprime 8 en pantalla.
Entonces, ¿qué retorna puts? No nos habíamos preocupado por eso, veamos ahora:

valorRetornado = puts 'Esto retorno puts:'
puts valorRetornado

Esto es lo que retorno puts:
nil

Así que el primer puts retornó nil. Aunque no lo probamos directamente, el segundo puts también lo hizo; puts siempre retorna nil. Todos los métodos devuelven algo, aún si sólo es nil.

Toma un pequeño descanso y escribe un programa con el que averigües que retorna el método muge.

¿Te sorprendió? Bueno, así es como funciona: el valor que retorna un método es simplemente la última línea del método. En el caso de muge, esto significa que retorna puts 'muuuuuuu...' * numeroDeVeces, lo cual es nil debido a que puts siempre devuelve nil. Si quisiéramos que todos nuestros métodos siempre retornaran la cadena 'submarino amarillo', tendríamos que poner eso en ellos al final:

def muge numeroDeVeces
  puts 'muuuuuuu...' * numeroDeVeces
  'submarino amarillo'
end

x = muge 2
puts x

muuuuuuu...muuuuuuu...
submarino amarillo

Entonces, intentemos ese experimento de psicología de nuevo, pero ésta vez escribiremos un método para hacer las preguntas por nosotros. Necesitará recibir la pregunta como parámetro, retornando como resultado true si es respondida con sí, mientras que retorna como resultado false si es respondida con no. (Aun cuando la mayor parte del tiempo ignoraremos la respuesta, es una buena idea que el método retorne el resultado. Así también podremos usar la pregunta sobre mojar la cama.) Además, acortaré la bienvenida y la explicación, para que sea más fácil de leer:

def hacer_pregunta pregunta
  buenaRespuesta = false

  while (not buenaRespuesta)
    puts pregunta
    respuesta = gets.chomp.downcase

    if (respuesta == 'sí' or respuesta == 'no')
      buenaRespuesta = true

      if respuesta == 'sí'
        resultado = true
      else
         resultado = false
      end
    else
       puts 'Por favor, responde «sí» o «no».'
    end
  end

  resultado # lo que queremos retornar (true o false)
end

puts 'Hola y gracias por...'
puts

# ignoramos los valores retornados...
hacer_pregunta '¿Te gusta comer tacos?'
hacer_pregunta '¿Te gusta comer burritos?'
# pero guardamos el valor que es retornado ésta ocasión
mojaLaCama = hacer_pregunta '¿Aún mojas la cama?'
hacer_pregunta '¿Te gusta comer chimichangas?'
hacer_pregunta '¿Te gusta comer sopapillas?'
hacer_pregunta '¿Te gusta comer tamales?'
puts 'Sólo unas preguntas más...'
hacer_pregunta '¿Te gusta beber horchata?'
hacer_pregunta '¿Te gusta comer flautas?'

puts 
puts 'EXPLICACIÓN:'
puts 'Te agradezco por...'
puts
puts mojaLaCama

Hola y gracias por...

¿Te gusta comer tacos?
sí
¿Te gusta comer burritos?
sí
¿Aún mojas la cama?
¡claro que no!
Por favor responde «sí» o «no».
¿Aún mojas la cama?
NO
¿Te gusta comer chimichangas?
sí
¿Te gusta comer sopapillas?
sí
¿Te gusta comer tamales?
sí
¿Te gusta beber horchata?
sí
¿Te gusta comer flautas?
sí

EXPLICACIÓN:
Te agradezco por...

false

Nada mal, ¿eh? Fuimos capaces de agregar más preguntas (y agregar preguntas es fácil ahora), además de que nuestro programa es mucho más corto. ¡Es una gran mejora! – El sueño de un programador flojo.
